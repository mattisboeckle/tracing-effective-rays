module src/lib/camera

import random
import bench

import src/lib/common
import src/lib/vec3
import src/lib/ray
import src/lib/ppm

record Camera(
  width: Int, height: Int, aspect_ratio: Double, 
  samples_per_pixel: Int, pixel_sample_scale: Double, max_depth: Int,
  center: Vec3, pixel00: Vec3, pixel_du: Vec3, pixel_dv: Vec3,
  u: Vec3, v: Vec3, w: Vec3)

def camera(width: Int, fov: Double, lookfrom: Vec3, lookat: Vec3, vup: Vec3, aspect_ratio: Double, samples_per_pixel: Int, max_depth: Int): Camera = {
  // Image
  val image_width = width
  val image_height = (image_width.toDouble / aspect_ratio).toInt

  val pixel_sample_scale = 1.0 / samples_per_pixel.toDouble

  // Camera
  val center = lookfrom
  
  val focal_length = (lookfrom - lookat).length()
  val theta = degrees_to_radians(fov)
  val h = tan(theta / 2.0)
  val viewport_height = 2.0 * h * focal_length
  val viewport_width = viewport_height * (image_width.toDouble / image_height.toDouble)

  val w = unit_vector(lookfrom - lookat)
  val u = unit_vector(cross(vup, w))
  val v = cross(w, u)

  // Viewport
  val viewport_u = viewport_width * u
  val viewport_v = viewport_height * v.neg
  val pixel_delta_u = viewport_u / image_width
  val pixel_delta_v = viewport_v / image_height
  val viewport_upper_left = center - (focal_length * w) - viewport_u / 2 - viewport_v / 2

  val pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v)

  Camera(image_width, image_height, aspect_ratio, 
    samples_per_pixel, pixel_sample_scale, max_depth,
    center, pixel00_loc, pixel_delta_u, pixel_delta_v,
    u, v, w  
  )
}

def render(camera: Camera): Image / { readColor, random } = {
  var pixels = Nil()

  each(0, camera.height) { j =>
    val line_time = timed {
      each(0, camera.width) { i =>
        var pixel_color = vec3::zero()
        each(0, camera.samples_per_pixel) { _ => 
          val r = camera.get_ray(i, j)
          pixel_color = pixel_color + do readColor(r)
        }
        val pixel = fromVec3(pixel_color * camera.pixel_sample_scale)
        pixels = Cons(pixel, pixels)
      }
    }
      
    println("Line took: " ++ formatMs(line_time) ++ ", remaining " ++ (camera.height - j).show)
  }

  Image(camera.width, camera.height, pixels.reverse)
}

def diffuseImage(camera: Camera, world: List[Hittable]): Image / random = {
  var image = Image(0,0,[])
  diffuseHandler(world, camera.max_depth) {
    image = camera.render()
  }
  image
}

def degrees_to_radians(deg: Double): Double = {
  deg * PI / 180.0
}

def get_ray(camera: Camera, i: Int, j: Int): Ray / random = {
  val offset = sample_square()
  val pixel_sample = camera.pixel00 
                      + ((i.toDouble + offset.x) * camera.pixel_du)
                      + ((j.toDouble + offset.y) * camera.pixel_dv)
  val ray_origin = camera.center
  val ray_direction = pixel_sample - ray_origin

  Ray(ray_origin, ray_direction)
}

def sample_square(): Vec3 / random = {
  Vec3(randomDouble() - 0.5, randomDouble() - 0.5, 0.0)
}