module src/lib/camera

import src/lib/vec3
import src/lib/ray
import src/lib/ppm

record Camera(width: Int, height: Int, aspect_ratio: Double, center: Vec3, pixel00: Vec3, pixel_du: Vec3, pixel_dv: Vec3)

def camera(width: Int, aspect_ratio: Double): Camera = {
  // Image
  val image_width = width
  val image_height = (image_width.toDouble / aspect_ratio).toInt

  // Camera
  
  val focal_length = 1.0
  val viewport_height = 2.0
  val viewport_width = viewport_height * (image_width.toDouble / image_height.toDouble)
  val camera_center = Vec3(0.0, 0.0, 0.0)

  // Viewport
  val viewport_u = Vec3(viewport_width, 0.0, 0.0)
  val viewport_v = Vec3(0.0, viewport_height.neg, 0.0)
  val pixel_delta_u = viewport_u / image_width
  val pixel_delta_v = viewport_v / image_height
  val viewport_upper_left = camera_center - Vec3(0.0, 0.0, focal_length) - viewport_u / 2 - viewport_v / 2

  val pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v)

  Camera(image_width, image_height, aspect_ratio, camera_center, pixel00_loc, pixel_delta_u, pixel_delta_v)
}

// args: width & height of image
// bargs:
//    colorCalc: function that returns the correct color for a given ray
// returns: Image constructed with color by 'colorCalc'
def render(camera: Camera) { colorCalc: Ray => Color }: Image = {

  var pixels = Nil()

  each(0, camera.height) { j =>
    println("Lines remaining: " ++ (camera.height - j).show)
    each(0, camera.width) { i =>
      val pixel_center = camera.pixel00 + (i * camera.pixel_du) + (j * camera.pixel_dv)
      val ray_direction = pixel_center - camera.center
      val r = Ray(camera.center, ray_direction)
      val color = withColorCalc { colorCalc } { do color(r) }
      pixels = Cons(fromVec3(color), pixels)
    }
  }

  Image(camera.width, camera.height, pixels.reverse)
}