import src/lib/vec3

import random

record Ray(origin: Vec3, direction: Vec3)

type Color = Vec3

def at(ray: Ray, r: Double): Vec3 = {
  ray.origin + r * ray.direction
}

def show(ray: Ray): String = {
  "Ray(" ++ ray.origin.show ++ ", " ++ ray.direction.show ++ ")"
}

effect color(r: Ray): Color

record HitRecord(point: Vec3, normal: Vec3, t: Double, material: Material)
record Interval(min: Double, max: Double)

def outside(value: Double, interval: Interval): Bool = value.inside(interval).not() 
def inside(value: Double, interval: Interval): Bool =  interval.min < value && value < interval.max
def clamp(value: Double, interval: Interval): Double = {
  if (value < interval.min)       interval.min
  else if (value > interval.max)  interval.max
  else                            value
}

type Material {
  Lambertian(albedo: Vec3)
  Metal(albedo: Vec3)
}

// Should produce a scattered ray and how much color was attenuated, based on the Material
def scatter(material: Material, r_in: Ray, hit_record: HitRecord): Option[(Vec3, Ray)] / random = material match {
  case Lambertian(albedo) => {
    var scatter_direction = hit_record.normal + random_unit_vector()

    if (scatter_direction.near_zero())
      scatter_direction = hit_record.normal

    val scattered = Ray(hit_record.point, scatter_direction)
    Some((albedo, scattered))
  }
  case Metal(albedo) => {
    val reflected = reflect(r_in.direction, hit_record.normal)
    val scattered = Ray(hit_record.point, reflected)

    Some((albedo, scattered))
  }
}

interface Hittable {
  def hit(r: Ray, interval: Interval): Option[HitRecord] 
}

record Sphere(center: Vec3, radius: Double)

def hittable(sphere: Sphere, material: Material): (Hittable at {}, Material) = sphere match {
  case Sphere(center, radius) => {
    (box new Hittable {
      def hit(r: Ray, interval: Interval) = {
        val oc = center - r.origin
        val a = r.direction.length_squared()
        val h = vec3::dot(r.direction, oc)
        val c = oc.length_squared() - radius * radius
        val discriminant = h * h - a * c
        
        if (discriminant < 0.0) {
          None()
        } else {
          var isNone = false
          val sqrtd = sqrt(discriminant)
          var root = (h - sqrtd) / a

          if (root.outside(interval)) {
            root = (h + sqrtd) / a
            if (root.outside(interval)) {
              isNone = true
            }
          }

          if (isNone) {
            None()
          } else {
            val rec_t = root
            val rec_p = r.at(rec_t)

            val outward_normal = (rec_p - center) / radius

            // Detect surface side
            val rec_n = if (dot(r.direction, outward_normal) < 0.0) {
              outward_normal
            } else {
              outward_normal.neg
            }

            Some(HitRecord(rec_p, rec_n, rec_t, material))
          }
        }
      }
    }, material)
  }
}

def hittable(list: List[(Hittable at {}, Material)]): Hittable at {} = {
  box new Hittable {
    def hit(r: Ray, interval: Interval) = {
      var temp_rec = HitRecord(zero(), zero(), 0.0, Lambertian(zero()))
      var hit_anything = false
      var closest_so_far = interval.max

      list.foreach { pair => {
        pair match {
          case (hittable, material) => {
            hittable.hit(r, Interval(interval.min, closest_so_far)) match {
              case None() => ()
              case Some(hit_record) => {
                hit_anything = true
                closest_so_far = hit_record.t
                temp_rec = hit_record
              }
            }
          }
        }
      }}

      if (hit_anything) {
        Some(temp_rec)
      } else {
        None()
      }
    }
  }
}

def withColorCalc { colorCalc: Ray => Color } { prog: () => Color / color } = {
  try { prog() }
  with color { r => colorCalc(r) }
}

def black(r: Ray): Color = {
  vec3::zero()
}

def gradient(r: Ray): Color = {
  val unit_direction = r.direction.unit_vector
  val blendFactor = 0.5 * (unit_direction.y + 1.0)
  (1.0 - blendFactor) * Vec3(1.0, 1.0, 1.0) + blendFactor * Vec3(0.5, 0.7, 1.0)
}

def one_sphere(r: Ray): Color / random = {
  val material = Lambertian(Vec3(0.5, 0.7, 1.0))
  val (sphere, _) = hittable(Sphere(Vec3(0.0, 0.0, -1.0), 0.5), material)
  val hit_record = sphere.hit(r, Interval(0.0, 10000.0))
  val t = hit_record match {
    case None() => -1.0
    case Some(rec) => rec.t
  }
  if (t > 0.0) {
    val n = (r.at(t) - Vec3(0.0, 0.0, -1.0)).unit_vector
    0.5 * Vec3(n.x + 1.0, n.y + 1.0, n.z + 1.0)
  } else {
    gradient(r)
  }
}

def hitables_default(hittables: List[(Hittable at {}, Material)], r: Ray): Color = {
  val world = hittable(hittables)
  val opt_rec = world.hit(r, Interval(0.0, 10000.0))
  opt_rec match {
    case None() => gradient(r)
    case Some(rec) => 0.5 * (rec.normal + Vec3(1.0, 1.0, 1.0))
  }
}

def hitables_diffuse(hittables: List[(Hittable at {}, Material)], r: Ray, depth: Int): Color / random = {
  if (depth <= 0) {
    vec3::zero()
  } else {
    val world = hittable(hittables)
    val opt_rec = world.hit(r, Interval(0.001, 10000.0))
    opt_rec match {
      case None() => gradient(r)
      case Some(rec) => {
        val opt_scatter = rec.material.scatter(r, rec)
        opt_scatter match {
          case Some((attenuation, scattered)) => attenuation * hitables_diffuse(hittables, scattered, depth - 1)
          case None() => Vec3(0.0, 0.0, 0.0)
        }
        // val direction = vec3::random_on_hemisphere(rec.normal)
        // val direction = rec.normal + vec3::random_unit_vector()
        // 0.5 * hitables_diffuse(hittables, Ray(rec.point, direction), depth - 1)
      }
    }
  }
}
