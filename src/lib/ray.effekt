import src/lib/common
import src/lib/vec3

import random

record Ray(origin: Vec3, direction: Vec3)

type Color = Vec3

def at(ray: Ray, r: Double): Vec3 = {
  ray.origin + r * ray.direction
}

def show(ray: Ray): String = {
  "Ray(" ++ ray.origin.show ++ ", " ++ ray.direction.show ++ ")"
}

effect color(r: Ray): Color

record HitRecord(point: Vec3, normal: Vec3, t: Double, material: Material, front_face: Bool)

type Material {
  Lambertian(albedo: Vec3)
  Metal(albedo: Vec3, fuzz: Double)
  Dielectric(refraction_index: Double)
}

def reflectance(cosine: Double, refraction_index: Double): Double = {
  var r0 = (1.0 - refraction_index) / (1.0 + refraction_index)
  r0 = r0 * r0
  r0 + (1.0 - r0) * pow(1.0 - cosine, 5)
}

// Should produce a scattered ray and how much color was attenuated, based on the Material
def scatter(material: Material, r_in: Ray, hit_record: HitRecord): Option[(Vec3, Ray)] / random = material match {
  case Lambertian(albedo) => {
    var scatter_direction = hit_record.normal + random_unit_vector()

    if (scatter_direction.near_zero())
      scatter_direction = hit_record.normal

    val scattered = Ray(hit_record.point, scatter_direction)
    Some((albedo, scattered))
  }
  case Metal(albedo, fuzz) => {
    val fuzz = if (fuzz < 1.0) fuzz else 1.0
    var reflected = reflect(r_in.direction, hit_record.normal)
    reflected = unit_vector(reflected) + (fuzz * random_unit_vector())
    val scattered = Ray(hit_record.point, reflected)

    if (dot(scattered.direction, hit_record.normal) > 0.0) {
      Some((albedo, scattered))
    } else {
      None()
    }
  }
  case Dielectric(refraction_index) => {
    val attenuation = Vec3(1.0, 1.0, 1.0)
    val ri = if (hit_record.front_face) 1.0 / refraction_index else refraction_index

    val unit_direction = unit_vector(r_in.direction)

    val cos_theta = min(dot(unit_direction.neg(), hit_record.normal), 1.0)
    val sin_theta = sqrt(1.0 - cos_theta * cos_theta)

    val cannot_refract = ri * sin_theta > 1.0
    var direction = vec3::zero()

    if (cannot_refract || reflectance(cos_theta, ri) > randomDouble())
      direction = reflect(unit_direction, hit_record.normal)
    else
      direction = refract(unit_direction, hit_record.normal, ri)

    val scattered = Ray(hit_record.point, direction)
    Some((attenuation, scattered))
  }
}

type Hittable {
  Sphere(material: Material, center: Vec3, radius: Double)
}

effect hit(rec: HitRecord): Color
effect miss(ray: Ray): Color

def calculateHit(hittable: Hittable, r: Ray, interval: Interval): Color / { hit, miss } = hittable match {
  case Sphere(material, center, radius) => {
    val oc = center - r.origin
    val a = r.direction.length_squared()
    val h = vec3::dot(r.direction, oc)
    val c = oc.length_squared() - radius * radius
    val discriminant = h * h - a * c
        
    if (discriminant < 0.0) {
      do miss(r)
    } else {
      var isSome = true
      val sqrtd = sqrt(discriminant)
      var root = (h - sqrtd) / a

      if (root.outside(interval)) {
        root = (h + sqrtd) / a
        if (root.outside(interval)) {
          isSome = false
        }
      }

      if (isSome) {
        val rec_t = root
        val rec_p = r.at(rec_t)

        val outward_normal = (rec_p - center) / radius

        // Detect surface side
        val (rec_n, front_face) = if (dot(r.direction, outward_normal) < 0.0) {
          (outward_normal, true)
        } else {
          (outward_normal.neg, false)
        }

        do hit(HitRecord(rec_p, rec_n, rec_t, material, front_face))
      } else {
        do miss(r)
      }
    }
  }
}

def calculateHits(list: List[Hittable], r: Ray, interval: Interval): Color / { hit, miss } = {
  var temp_rec = HitRecord(vec3::zero(), vec3::zero(), 0.0, Lambertian(vec3::zero()), true)
  var hit_anything = false
  var closest_so_far = interval.max

  list.foreach { hittable => {
    try { 
      hittable.calculateHit(r, Interval(interval.min, closest_so_far))
      ()
    }
    with hit { rec => 
      hit_anything = true
      closest_so_far = rec.t
      temp_rec = rec
    }
    with miss { ray =>
      ()
    }
  }}

  if (hit_anything) {
    do hit(temp_rec)
  } else {
    do miss(r)
  }
}

def withColorCalc { colorCalc: Ray => Color } { prog: () => Color / color } = {
  try { prog() }
  with color { r => colorCalc(r) }
}

def black(r: Ray): Color = {
  vec3::zero()
}

def gradient(r: Ray): Color = {
  val unit_direction = r.direction.unit_vector
  val blendFactor = 0.5 * (unit_direction.y + 1.0)
  (1.0 - blendFactor) * Vec3(1.0, 1.0, 1.0) + blendFactor * Vec3(0.5, 0.7, 1.0)
}

def one_sphere(r: Ray): Color / random = {
  val material = Lambertian(Vec3(0.5, 0.7, 1.0))
  val sphere = Sphere(material, Vec3(0.0, 0.0, -1.0), 0.5)
  try sphere.calculateHit(r, Interval(0.0, 10000.0))
  with hit { rec => 
    if (rec.t > 0.0) {
      val n = (r.at(rec.t) - Vec3(0.0, 0.0, -1.0)).unit_vector
      0.5 * Vec3(n.x + 1.0, n.y + 1.0, n.z + 1.0)
    } else {
      gradient(r)
    }
  }
  with miss { _ => gradient(r) }
  
}

def hitables_diffuse(world: List[Hittable], r: Ray, depth: Int): Color / random = {
  if (depth <= 0) {
    vec3::zero()
  } else {
    try {
      world.calculateHits(r, Interval(0.001, 10000.0))
    }
    with hit { rec => 
      val opt_scatter = rec.material.scatter(r, rec)
      opt_scatter match {
        case Some((attenuation, scattered)) => attenuation * hitables_diffuse(world, scattered, depth - 1)
        case None() => Vec3(0.0, 0.0, 0.0)
      }
    }
    with miss { ray =>
      gradient(r)
    }
  }
}
