import src/lib/vec3

record Ray(origin: Vec3, direction: Vec3)

type Color = Vec3

def at(ray: Ray, r: Double): Vec3 = {
  ray.origin + r * ray.direction
}

effect color(r: Ray): Color

record HitRecord(point: Vec3, normal: Vec3, t: Double)
record Interval(min: Double, max: Double)

def outside(value: Double, interval: Interval): Bool = value <= interval.min || interval.max <= value
def inside(value: Double, interval: Interval): Bool = value.outside(interval).not()

interface Hittable {
  def hit(r: Ray, interval: Interval): Option[HitRecord] 
}

record Sphere(center: Vec3, radius: Double)

def hittable(sphere: Sphere): Hittable at {} = sphere match {
  case Sphere(center, radius) => {
    box new Hittable {
      def hit(r: Ray, interval: Interval) = {
        val oc = center - r.origin
        val a = r.direction.length_squared()
        val h = vec3::dot(r.direction, oc)
        val c = oc.length_squared() - radius * radius
        val discriminant = h * h - a * c
        
        if (discriminant < 0.0) {
          None()
        } else {
          var isNone = false
          val sqrtd = sqrt(discriminant)
          var root = (h - sqrtd) / a

          if (root.outside(interval)) {
            root = (h + sqrtd) / a
            if (root.outside(interval)) {
              isNone = true
            }
          }

          if (isNone) {
            None()
          } else {
            val rec_t = root
            val rec_p = r.at(rec_t)

            val outward_normal = (rec_p - center) / radius

            // Detect surface side
            val rec_n = if (dot(r.direction, outward_normal) < 0.0) {
              outward_normal
            } else {
              outward_normal.neg
            }

            Some(HitRecord(rec_p, rec_n, rec_t))
          }
        }
      }
    }
  }
}

def hittable(list: List[Hittable at {}]): Hittable at {} = {
  box new Hittable {
    def hit(r: Ray, interval: Interval) = {
      var temp_rec = HitRecord(zero(), zero(), 0.0)
      var hit_anything = false
      var closest_so_far = interval.max

      list.foreach { obj => {
        obj.hit(r, Interval(interval.min, closest_so_far)) match {
          case None() => ()
          case Some(hit_record) => {
            hit_anything = true
            closest_so_far = hit_record.t
            temp_rec = hit_record
          }
        }
      }}

      if (hit_anything) {
        Some(temp_rec)
      } else {
        None()
      }
    }
  }
}

def withColorCalc { colorCalc: Ray => Color } { prog: () => Color / color } = {
  try { prog() }
  with color { r => colorCalc(r) }
}

def black(r: Ray): Color = {
  vec3::zero()
}

def gradient(r: Ray): Color = {
  val unit_direction = r.direction.unit_vector
  val blendFactor = 0.5 * (unit_direction.y + 1.0)
  (1.0 - blendFactor) * Vec3(1.0, 1.0, 1.0) + blendFactor * Vec3(0.5, 0.7, 1.0)
}

def one_sphere(r: Ray): Color = {
  val sphere = hittable(Sphere(Vec3(0.0, 0.0, -1.0), 0.5))
  val hit_record = sphere.hit(r, Interval(0.0, 10000.0))
  val t = hit_record match {
    case None() => -1.0
    case Some(rec) => rec.t
  }
  if (t > 0.0) {
    val n = (r.at(t) - Vec3(0.0, 0.0, -1.0)).unit_vector
    0.5 * Vec3(n.x + 1.0, n.y + 1.0, n.z + 1.0)
  } else {
    gradient(r)
  }
}

def hittables(hittables: List[Hittable at {}], r: Ray): Color = {
  val world = hittable(hittables)
  val opt_rec = world.hit(r, Interval(0.0, 10000.0))
  opt_rec match {
    case None() => gradient(r)
    case Some(rec) => 0.5 * (rec.normal + Vec3(1.0, 1.0, 1.0))
  }
}
