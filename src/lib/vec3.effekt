module lib/vec3

import random

record Vec3(x: Double, y: Double, z: Double)

def infixAdd(a: Vec3, b: Vec3): Vec3 = (a, b) match {
  case (Vec3(x1, y1, z1), Vec3(x2, y2, z2)) => Vec3(x1 + x2, y1 + y2, z1 + z2)
}
def infixSub(a: Vec3, b: Vec3): Vec3 = (a, b) match {
  case (Vec3(x1, y1, z1), Vec3(x2, y2, z2)) => Vec3(x1 - x2, y1 - y2, z1 - z2)
}
def infixMul(v: Vec3, t: Double): Vec3 = v match {
  case Vec3(x, y, z) => Vec3(x * t, y * t, z * t)
}
def infixMul(t: Double, v: Vec3): Vec3 = v * t
def infixMul(t: Int, v: Vec3): Vec3 = v * t.toDouble
def infixMul(v: Vec3, t: Int): Vec3 = v * t.toDouble

def infixMul(v: Vec3, u: Vec3): Vec3 = Vec3(v.x * u.x, v.y * u.y, v.z * u.z)

def infixDiv(v: Vec3, t: Double): Vec3 = v * (1.0 / t)
def infixDiv(v: Vec3, t: Int): Vec3 = v * (1.0 / t.toDouble)

def infixEq(a: Vec3, b: Vec3): Bool = {
  a.x == b.x && a.y == b.y && a.z == b.z
}

def zero(): Vec3 = Vec3(0.0, 0.0, 0.0)

def neg(v: Vec3) = v match {
  case Vec3(x, y, z) => Vec3(x.neg, y.neg, z.neg)
}

def length_squared(v: Vec3) = v match {
  case Vec3(x, y, z) => x * x + y * y + z * z
}
def length(v: Vec3) = sqrt(v.length_squared)

def dot(a: Vec3, b: Vec3): Double = (a, b) match {
  case (Vec3(x1, y1, z1), Vec3(x2, y2, z2)) => x1 * x2 + y1 * y2 + z1 * z2
}

def cross(a: Vec3, b: Vec3): Vec3 = (a, b) match {
  case (Vec3(x1, y1, z1), Vec3(x2, y2, z2)) => 
    Vec3(y1 * z2 - z1 * y2,
         z1 * x2 - x1 * z2,
         x1 * y2 - y1 * x2)
}

def unit_vector(v: Vec3): Vec3 = v / v.length

def show(v: Vec3): String = v match {
  case Vec3(x, y, z) => "(" ++ x.show ++ ", " ++ y.show ++ ", " ++ z.show ++ ")"
}

def near_zero(v: Vec3): Bool = {
  val epsilon = 0.000000001
  abs(v.x) < epsilon && abs(v.y) < epsilon && abs(v.z) < epsilon
}

def reflect(v: Vec3, n: Vec3): Vec3 = {
  v - 2.0 * dot(v, n) * n
}

def refract(uv: Vec3, n: Vec3, etai_over_etat: Double): Vec3 = {
  val cos_theta = min(dot(uv.neg(), n), 1.0)
  val r_out_perp = etai_over_etat * (uv * cos_theta * n)
  val r_out_parallel = sqrt(abs(1.0 - r_out_perp.length_squared())).neg() * n
  r_out_perp + r_out_parallel
}

def random_double(min: Double, max: Double): Double / random = {
  min * (max - min) * randomDouble()
}

def random(): Vec3 / random = {
  Vec3(randomDouble(), randomDouble(), randomDouble())
}

def random(min: Double, max: Double): Vec3 / random = {
  Vec3(random_double(min, max), random_double(min, max), random_double(min, max))
}

def random_unit_vector(): Vec3 / random = {
  var ret = zero() 
  loop { {l} =>
    val p = random(-1.0, 1.0)
    val lensq = p.length_squared()
    // The book uses 1e-160 here for epsilon instead
    // The right is a hack, because LLVM can't do Double Lte, but only Lt
    val epsilon = 0.00000001
    if (epsilon < lensq && lensq < 1.0 + epsilon) {
      ret = p / sqrt(lensq)
      l.break()
    }
  }
  ret
}

def random_on_hemisphere(normal: Vec3): Vec3 / random = {
  val on_unit_sphere = random_unit_vector()
  if (dot(on_unit_sphere, normal) > 0.0) {
    on_unit_sphere
  } else {
    on_unit_sphere.neg
  }
}
