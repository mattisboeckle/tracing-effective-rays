module main // must be named same as the file!

import random

import src/lib/common
import src/lib/ppm
import src/lib/vec3
import src/lib/ray
import src/lib/camera

import io/error

def dielectric_scene(): List[Hittable] = {
  val material_ground = Lambertian(Vec3(0.8, 0.8, 0.0))
  val material_center = Lambertian(Vec3(0.1, 0.2, 0.5))
  val material_left = Dielectric(1.5)
  val material_bubble = Dielectric(1.0 / 1.5)
  val material_right = Metal(Vec3(0.8, 0.6, 0.2), 1.0)

  val sphere_ground = Sphere(material_ground, Vec3(0.0, -100.5, -1.0), 100.0)
  val sphere_center = Sphere(material_center, Vec3(0.0, 0.0, -1.2), 0.5)
  val sphere_left   = Sphere(material_left, Vec3(-1.0, 0.0, -1.0), 0.5)
  val sphere_bubble = Sphere(material_bubble, Vec3(-1.0, 0.0, -1.0), 0.4)
  val sphere_right  = Sphere(material_right, Vec3(1.0, 0.0, -1.0), 0.5)

  [
    sphere_ground, 
    sphere_center, 
    sphere_left,
    sphere_bubble,
    sphere_right,
  ]
}

def camera_test_scene(): List[Hittable] = {
  val R = cos(PI / 4.0)

  val material_left = Lambertian(Vec3(0.0, 0.0, 1.0))
  val material_right = Lambertian(Vec3(1.0, 0.0, 0.0))

  val sphere_left = Sphere(material_left, Vec3(R.neg(), 0.0, -1.0), R)
  val sphere_right = Sphere(material_right, Vec3(R, 0.0, -1.0), R)

  [
    sphere_left,
    sphere_right
  ]
}

def final_scene(): List[Hittable] / random = {
  var world: List[Hittable] = Nil()
  
  val material_ground = Lambertian(Vec3(0.5, 0.5, 0.5))

  world = Cons(Sphere(material_ground, Vec3(0.0, -1000.0, 0.0), 1000.0), world)

  effekt::each(-11, 11) { a =>
    effekt::each(-11, 11) { b =>
      val choose_mat = randomDouble()
      val center = Vec3(a.toDouble + 0.9 * randomDouble(), 0.2, b.toDouble + 0.9 * randomDouble())

      if ((center - Vec3(4.0, 0.2, 0.0)).length() > 0.9) {
        if (choose_mat < 0.8) {
          // diffuse
          val albedo = vec3::random() * vec3::random()
          val mat = Lambertian(albedo)
          world = Cons(Sphere(mat, center, 0.2), world)
        } else if (choose_mat < 0.95) {
          // metal
          val albedo = vec3::random(0.5, 1.0)
          val fuzz = random_double(0.0, 0.5)
          val mat = Metal(albedo, fuzz)
          world = Cons(Sphere(mat, center, 0.2), world)
        } else {
          // glass
          val mat = Dielectric(1.5)
          world = Cons(Sphere(mat, center, 0.2), world)
        }
      }
    }
  }

  val mat1 = Dielectric(1.5)
  world = Cons(Sphere(mat1, Vec3(0.0, 1.0, 0.0), 1.0), world)

  val mat2 = Lambertian(Vec3(0.4, 0.2, 0.1))
  world = Cons(Sphere(mat2, Vec3(-4.0, 1.0, 0.0), 1.0), world)

  val mat3 = Metal(Vec3(0.7, 0.6, 0.5), 0.0)
  world = Cons(Sphere(mat3, Vec3(4.0, 1.0, 0.0), 1.0), world)

  world
}

def main(): Unit = {
  with on[IOError].panic
  with minstd(128)
  
  // Customize the scene
  // val world = dielectric_scene()
  // val world = camera_test_scene()
  val world = final_scene()

  // Customize parameters here
  val width = 400
  val samples_per_pixel = 10
  val max_depth = 3

  // Usually don't need to be changed
  val fov = 20.0
  val lookfrom = Vec3(13.0, 2.0, 3.0)
  val lookat = Vec3(0.0, 0.0, 0.0)
  val vup = Vec3(0.0, 1.0, 0.0)
  val aspect_ratio = 16.0 / 9.0
  
  val camera = camera(width, fov, lookfrom, lookat, vup, aspect_ratio, samples_per_pixel, max_depth)

  val image = camera.diffuseImage(world)
  image.writeToFile("out.ppm")

  ()
}
