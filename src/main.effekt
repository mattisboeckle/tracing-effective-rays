module main // must be named same as the file!

import random

import src/lib/ppm
import src/lib/vec3
import src/lib/ray
import src/lib/camera

import io/error

def dielectric_scene(): List[(Hittable at {}, Material)] = {
  val material_ground = Lambertian(Vec3(0.8, 0.8, 0.0))
  val material_center = Lambertian(Vec3(0.1, 0.2, 0.5))
  val material_left = Dielectric(1.5)
  val material_bubble = Dielectric(1.0 / 1.5)
  val material_right = Metal(Vec3(0.8, 0.6, 0.2), 1.0)

  val sphere_ground = Sphere(Vec3(0.0, -100.5, -1.0), 100.0)
  val sphere_center = Sphere(Vec3(0.0, 0.0, -1.2), 0.5)
  val sphere_left   = Sphere(Vec3(-1.0, 0.0, -1.0), 0.5)
  val sphere_bubble = Sphere(Vec3(-1.0, 0.0, -1.0), 0.4)
  val sphere_right  = Sphere(Vec3(1.0, 0.0, -1.0), 0.5)

  val world = [
    hittable(sphere_ground, material_ground), 
    hittable(sphere_center, material_center), 
    hittable(sphere_left, material_left),
    hittable(sphere_bubble, material_bubble),
    hittable(sphere_right, material_right),
  ]

  world
}

def camera_test_scene(): List[(Hittable at {}, Material)] = {
  val R = cos(PI / 4.0)

  val material_left = Lambertian(Vec3(0.0, 0.0, 1.0))
  val material_right = Lambertian(Vec3(1.0, 0.0, 0.0))

  val sphere_left = Sphere(Vec3(R.neg(), 0.0, -1.0), R)
  val sphere_right = Sphere(Vec3(R, 0.0, -1.0), R)

  val world = [
    hittable(sphere_left, material_left),
    hittable(sphere_right, material_right)
  ]

  world
}

def main(): Unit = {
  with on[IOError].panic
  
  val world = dielectric_scene()
  // val world = camera_test_scene()

  with minstd(128)
  val width = 400
  val fov = 90.0
  val lookfrom = Vec3(0.0, 0.0, 0.0)
  val lookat = Vec3(0.0, 0.0, -1.0)
  val vup = Vec3(0.0, 1.0, 0.0)
  val aspect_ratio = 16.0 / 9.0
  val samples_per_pixel = 100
  val max_depth = 50
  val camera = camera(width, fov, lookfrom, lookat, vup, aspect_ratio, samples_per_pixel, max_depth)
  camera.render { r => ray::hitables_diffuse(world, r, camera.max_depth) }.writeToFile("out.ppm")

  ()
}
